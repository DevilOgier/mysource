
1. 如何提高存储性能?
现在整个存储的性能瓶颈主要在后端HDD的随机读写性能过差，主要的解决办法有使用SSD缓存（bcache），
使用写日志，可以把随机io转成顺序io,然后再异步刷入到磁盘中。对于那些有突发大量随机io的写性能会
很好，如果是持续随机io的，最好有独立的日志盘。刷日志的时候可以进行io排序。

2. 如何提高tgt性能？
tgt处理前段(iscsiadm)网络请求使用的是单线程epoll,大io读写过程会出现单线程瓶颈(线程的cpu使用率达到90多以上)，
把每个tcp连接放到不同的epoll中，每个epoll使用一个线程，使用多路径负载均衡来提高tgt性能。

3. 自动精简配置(稀疏文件)的问题
刚开始性能很好，但是跑了一段时间之后性能就下降很快，主要是一个大文件的随机写会导致文件被切成很多段，（xfs和ext4都是基于段来记录文件数据位置），只是会有大量的文件元数据落盘，导致性能很差，xfs比ext4差，即使先预分配 fallocate -l 128G /mnt/test/data 结果也是一样。因为预分配只能保证大部分物理地址连续，但是哪些段有写过哪些段只预留还能写过也是要记录的，还是会导致很多段。即使有很多段，但是写过一篇再来覆盖写，性能就能保持最好，因为这时不用更新元数据了。（总结：大文件如果太过分散，导致分段太多，元数据会比较大，导致写性能极差）

4. ext4 fiemap 调用，如果文件分段比较多，耗时可能超过半个小时，导致文件系统不能用，xfs是秒级返回

5. 缓存的问题
缓存刷盘时也不是越快越好，如果后端磁盘使用率100%，会导致顺序IO(透传了)延时超大，读IO延时也很多（如果没中缓存）

6. 集群应用的问题，io均衡
不同卷要做到io均衡，不然一个卷使用大IO进行读写时，其他小IO读写的卷性能就能差，iops下降严重。在用户态用小跟堆实现一个简单的io均衡器，分值越大优先级越低，
每次io之后分值加上io长度。

7. 重建也要限制磁盘使用率，不然会导致前端使用很卡。
分析前段io占用比例，自动限制重建的数据。

8. tcp性能优化
用户态buffer cache,降低系统调用数。

9. 纯异步架构减低延时。

10. 使用共享内存加速进程间通信。

11. 使用内存池减少gc
4K 8K 16K 32K 2*32K 3*32K 4*32K ***  1M

12. qos 实现
例如要现在iops为10000，我们取阈值为9000（根据设置的iops计算出来），有个变量writeIoCount在每次写io都会加1，定时器会一秒后会自动清零，
如果在某次写之后，writeIoCount大于设置的阈值时，此时通过睡眠来控制io速度，时间为 (10000- writeIoCount)/   1S -（当前时间-上次清零时间）
在io比较小时，开销比较小，也不会睡眠增大延时。

13. 如何降低磁盘碎片。
自动精简配置(truncate)由于不用先分配磁盘空间，只有在第一次写入才会分配磁盘空间,如果有大量随机小io写，会导致文件在逻辑地址上连续的，在磁盘上
（物理地址）确实不连续的，这时即使是顺序读，性能也很差。解决办法，每次写的时候，用fallocate先预留1M磁盘空间，这样可以减少磁盘碎片。

14. 存储后端支持空间自动收缩(unmap 0x42)
fstrim 和格式化是会调用,真正回收磁盘空间

15. 纠删码加速，求逆矩阵使用缓存，不用每次都计算，直接从缓存拿就好， 乘除运算使用查表法，加减法一样都是异或运算（伽罗华域运算）。

16. 树形快照所做的优化
  1、在线顶层快照删除
  2、加速快照删除（计算向上合并或向下合并的数据量，使用最优方案）
  3、使用多级索引减少内存使用，索引内存可以回收
 
17. 链接克隆的优点
  1、减少磁盘空间消耗
  2、可以做到秒级克隆
  3、避免虚拟机启动风暴
  
18. 精简配置大大增加了完全克隆的速度，特别是从模版克隆虚拟机
  
19. 重建加速
  1. 大文件分段哈希，分段重建
  2. 稀疏文件快速重建
 
20. 创建加速
  批量接口和blotdb 批量操作





